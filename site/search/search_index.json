{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quick-SQLite A high-level SQLite3 wrapper that makes using SQLite databases much, much easier. Documentation Discord Support PyPI Page Dependants Documentation Website Discord Support Server PyPI Home Page Open-Source Dependants Data is persistent and file-stored Designed to be easy & clean to use by anyone Discord Support Supports the entire SQL API Built with event listeners for monitoring Introduction Quick-SQLite is intended for programmers that dislike the unattractive and needlessly extensive SQLite3 API. Quick-SQLite not only reduces the ugly-looking function set with a clean and organised function set, but it also comes with many useful settings such as auto-commiting, automatic reconnecting, and event listeners. The integrated events listeners - demonstrated later on - are functions inside your script that are called every time something specific happens, for example, the disconnect listener is called everytime the connection disconnects, more on that later. Comparison SQLite3 from sqlite3 import connect with connect ( \"Database.db\" ) as c : data = c . cursor () . execute ( \"SELECT Z FROM Table WHERE X=?\" , ( \"Y\" ,)) . fetchone ()[ 0 ] c . cursor () . execute ( \"UPDATE Table SET X=? WHERE X=?\" , ( \"Y\" , f \"{data}Y\" )) c . commit () Quick-SQLite from quicksqlite import Connection c = Connection ( path = \"Database.db\" , auto_connect = True ) c . update ( \"Table\" , \"X\" , f \"{c.select('Table', 'Z', column_w='X', value_w='Y')[0]}Y\" ) Quick Examples Basic Usage from quicksqlite import Connection c = Connection ( path = \"Database.db\" , auto_commit = False , reconnects = 5 , auto_connect = True ) c . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) # Do other stuff... c . close () Using Listeners from quicksqlite import Connection c = Connection ( path = \"Database.db\" , auto_commit = True , reconnects = 5 ) @c.listen def on_connect ( db ): print ( f \"Connected to {db}\" ) @c.listen def on_disconnect ( db ): print ( f \"Disconnected from {db}\" ) c . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) # Do other stuff... c . close () Using a Class from quicksqlite import Connection class MyClass ( Connection ): def __init__ ( self ): super () . __init__ ( path = \"Database.db\" , auto_commit = True , reconnects = 5 ) self . listen ( self . on_connect ) self . listen ( self . on_disconnect ) def on_connect ( self , db ): print ( f \"Connected to {db}\" ) def on_disconnect ( self , db ): print ( f \"Disconnected from {db}\" ) if __name__ == \"__main__\" : c = MyClass () c . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) # Do other stuff... c . close ()","title":"Home"},{"location":"#quick-sqlite","text":"A high-level SQLite3 wrapper that makes using SQLite databases much, much easier. Documentation Discord Support PyPI Page Dependants Documentation Website Discord Support Server PyPI Home Page Open-Source Dependants Data is persistent and file-stored Designed to be easy & clean to use by anyone Discord Support Supports the entire SQL API Built with event listeners for monitoring","title":"Quick-SQLite"},{"location":"#introduction","text":"Quick-SQLite is intended for programmers that dislike the unattractive and needlessly extensive SQLite3 API. Quick-SQLite not only reduces the ugly-looking function set with a clean and organised function set, but it also comes with many useful settings such as auto-commiting, automatic reconnecting, and event listeners. The integrated events listeners - demonstrated later on - are functions inside your script that are called every time something specific happens, for example, the disconnect listener is called everytime the connection disconnects, more on that later.","title":"Introduction"},{"location":"#comparison","text":"","title":"Comparison"},{"location":"#sqlite3","text":"from sqlite3 import connect with connect ( \"Database.db\" ) as c : data = c . cursor () . execute ( \"SELECT Z FROM Table WHERE X=?\" , ( \"Y\" ,)) . fetchone ()[ 0 ] c . cursor () . execute ( \"UPDATE Table SET X=? WHERE X=?\" , ( \"Y\" , f \"{data}Y\" )) c . commit ()","title":"SQLite3"},{"location":"#quick-sqlite_1","text":"from quicksqlite import Connection c = Connection ( path = \"Database.db\" , auto_connect = True ) c . update ( \"Table\" , \"X\" , f \"{c.select('Table', 'Z', column_w='X', value_w='Y')[0]}Y\" )","title":"Quick-SQLite"},{"location":"#quick-examples","text":"","title":"Quick Examples"},{"location":"#basic-usage","text":"from quicksqlite import Connection c = Connection ( path = \"Database.db\" , auto_commit = False , reconnects = 5 , auto_connect = True ) c . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) # Do other stuff... c . close ()","title":"Basic Usage"},{"location":"#using-listeners","text":"from quicksqlite import Connection c = Connection ( path = \"Database.db\" , auto_commit = True , reconnects = 5 ) @c.listen def on_connect ( db ): print ( f \"Connected to {db}\" ) @c.listen def on_disconnect ( db ): print ( f \"Disconnected from {db}\" ) c . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) # Do other stuff... c . close ()","title":"Using Listeners"},{"location":"#using-a-class","text":"from quicksqlite import Connection class MyClass ( Connection ): def __init__ ( self ): super () . __init__ ( path = \"Database.db\" , auto_commit = True , reconnects = 5 ) self . listen ( self . on_connect ) self . listen ( self . on_disconnect ) def on_connect ( self , db ): print ( f \"Connected to {db}\" ) def on_disconnect ( self , db ): print ( f \"Disconnected from {db}\" ) if __name__ == \"__main__\" : c = MyClass () c . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) # Do other stuff... c . close ()","title":"Using a Class"},{"location":"docs/","text":"API Reference This page will run through every portion of the module in depth. Connection class quick-sqlite. Connection ( path=\":memory:\", auto_commit=True, reconnects=3 auto_connect=False ) Represents a database connection path The database file location to connect to. If this file doesn't exist it is automatically created. If the path is specified as :memory: , the database is held in RAM; beware that if the memory is wiped (i.e: the machine powers down) then all held data is lost. Defaults to :memory: auto_commit bool - If set to True, changes are automatically saved when an operation is executed, this removes access to the Connection.commit function. If this is set to False, changes can only be saved by calling the Connection.commit function. Defaults to True reconnects int - The number of times to reconnect upon disconnect before erroring and closing the connection. Reconnections aren't very common but will be triggered if a database becomes locked. Defaults to 3 auto_connect bool - If set to True, a connection is automatically established, this removes access to the Connection.connect function, however the on_connect event won't be triggered. If this is set to False, a connection can only be established by calling the Connection.connect function, however on_connect will be called upon connection. Defaults to False connect () Attempts to connect to the database & triggers the on_connect event. Only available if Connection.auto_connect is set to False close () Attempts to close to the database & triggers the on_disconnect event. commit () Attempts to commit pending changes & triggers the on_commit event. Only available if Connection.auto_commit is set to False rollback () Rolls back the most recent commit & triggers the on_rollback event. listen ( func, name=None ) Adds a function to the event listener cache. When an event is dispatched, the function in cache is called. This can be used as a function decorator or as an independant function. Parameters func - The function to add to event cache. name ( str ) - The name of the event listener to register as. create_table ( table_name, values, types ) Creates a table in the connected database, if it already exists, the error is silently suppressed. Parameters table_name ( str ) - The name of the table to create. values ( list ) - A list of column names. types ( list ) - The respective data types for each column in values. create_table ( table_name ) Deletes a table in the connected database. Parameters table_name ( str ) - The name of the table to delete. insert ( table_name, values ) Inserts a list of data into a table. Parameters table_name ( str ) - The name of the table to insert into. values ( list ) - A list of data to insert. delete ( table_name, column_w=None, value_w=None ) Deletes data from a table. Parameters table_name ( str ) - The name of the table to delete from. column_w ( str ) - The column that is searched for when finding the entries to delete. value_w ( str ) - The data to look for alongside column_w. update ( table_name, column, value, column_w=None, value_w=None ) Updates a row in the provided table. Parameters table_name ( str ) - The name of the table to delete from. column ( str ) - The column to update. value ( str ) - The data to update the column to. column_w ( str ) - The column that is searched for when finding the entries to delete. value_w ( str ) - The data to look for alongside column_w. select ( table_name, select, column_w=None, value_w=None, fetchall=False, limit=None, random=False ) Selects data from a table. Parameters table_name ( str ) - The name of the table to delete from. select ( str ) - The column to select. column_w ( str ) - The column that is searched for when finding the entries to delete. value_w ( str ) - The data to look for alongside column_w. fetchall ( bool ) - Whether to fetch all relevant rows or just the first. limit ( int ) - The max number of rows to select, defaults to 1 . random ( bool ) - Whether or not fetch the rows in a random order. Event Reference quick-sqlite. on_connect ( database ) quick-sqlite. on_disconnect ( database ) An event called whenever a connection is successfully established or closed. The on_connect event is not available if Connection.auto_connect is set to True . Parameters database ( str ) - The path to the relevant database. quick-sqlite. on_reconnect ( database, attempt ) An event called whenever a connection is re-established. Parameters database ( str ) - The path to the relevant database. attempt ( int ) - The number of attempts taken to reconnect. quick-sqlite. on_commit ( database ) An event called whenever a database is commited to. database ( str ) - The path to the relevant database. quick-sqlite. on_rollback ( database ) An event called whenever a database's most recent commit is rolledback. database ( str ) - The path to the relevant database. quick-sqlite. on_transaction_success ( database, action ) An event called whenever an operation is performed on a database. database ( str ) - The path to the relevant database. action ( str ) - The action executed on the database.","title":"API Reference"},{"location":"docs/#api-reference","text":"This page will run through every portion of the module in depth.","title":"API Reference"},{"location":"docs/#connection","text":"class quick-sqlite. Connection ( path=\":memory:\", auto_commit=True, reconnects=3 auto_connect=False ) Represents a database connection path The database file location to connect to. If this file doesn't exist it is automatically created. If the path is specified as :memory: , the database is held in RAM; beware that if the memory is wiped (i.e: the machine powers down) then all held data is lost. Defaults to :memory: auto_commit bool - If set to True, changes are automatically saved when an operation is executed, this removes access to the Connection.commit function. If this is set to False, changes can only be saved by calling the Connection.commit function. Defaults to True reconnects int - The number of times to reconnect upon disconnect before erroring and closing the connection. Reconnections aren't very common but will be triggered if a database becomes locked. Defaults to 3 auto_connect bool - If set to True, a connection is automatically established, this removes access to the Connection.connect function, however the on_connect event won't be triggered. If this is set to False, a connection can only be established by calling the Connection.connect function, however on_connect will be called upon connection. Defaults to False connect () Attempts to connect to the database & triggers the on_connect event. Only available if Connection.auto_connect is set to False close () Attempts to close to the database & triggers the on_disconnect event. commit () Attempts to commit pending changes & triggers the on_commit event. Only available if Connection.auto_commit is set to False rollback () Rolls back the most recent commit & triggers the on_rollback event. listen ( func, name=None ) Adds a function to the event listener cache. When an event is dispatched, the function in cache is called. This can be used as a function decorator or as an independant function. Parameters func - The function to add to event cache. name ( str ) - The name of the event listener to register as. create_table ( table_name, values, types ) Creates a table in the connected database, if it already exists, the error is silently suppressed. Parameters table_name ( str ) - The name of the table to create. values ( list ) - A list of column names. types ( list ) - The respective data types for each column in values. create_table ( table_name ) Deletes a table in the connected database. Parameters table_name ( str ) - The name of the table to delete. insert ( table_name, values ) Inserts a list of data into a table. Parameters table_name ( str ) - The name of the table to insert into. values ( list ) - A list of data to insert. delete ( table_name, column_w=None, value_w=None ) Deletes data from a table. Parameters table_name ( str ) - The name of the table to delete from. column_w ( str ) - The column that is searched for when finding the entries to delete. value_w ( str ) - The data to look for alongside column_w. update ( table_name, column, value, column_w=None, value_w=None ) Updates a row in the provided table. Parameters table_name ( str ) - The name of the table to delete from. column ( str ) - The column to update. value ( str ) - The data to update the column to. column_w ( str ) - The column that is searched for when finding the entries to delete. value_w ( str ) - The data to look for alongside column_w. select ( table_name, select, column_w=None, value_w=None, fetchall=False, limit=None, random=False ) Selects data from a table. Parameters table_name ( str ) - The name of the table to delete from. select ( str ) - The column to select. column_w ( str ) - The column that is searched for when finding the entries to delete. value_w ( str ) - The data to look for alongside column_w. fetchall ( bool ) - Whether to fetch all relevant rows or just the first. limit ( int ) - The max number of rows to select, defaults to 1 . random ( bool ) - Whether or not fetch the rows in a random order.","title":"Connection"},{"location":"getting-started/","text":"Getting Started This page provides a basic setup guide. Installation pip install quick-sqlite Tip If recieve an error stating that the 'pip command cannot be found', or if you have both Python 3 & Python 2 installed, try doing: pip3 install quick-sqlite Basic Concepts Quick-SQLite revolves around the concept of executing operations via a function which then compiles the provided data into valid SQL, which is soon after executed. For example when the Connection.insert function is called, the provided data is compiled into SQL which would look something like INSERT INTO Table VALUES (Value Type...) . This module also revolves around the idea of making database monitoring much easier via events and connection issues a thing of the past. Here's a quick showcase on how events work: from quicksqlite import Connection con = Connection ( auto_connect = False ) @c.listen def on_connect ( db ): print ( f \"Connection to {db} has been established\" ) @c.listen def on_disconnect ( db ): print ( f \"Connection to {db} has been closed\" ) con . connect () # Do operations here... con . close () Warning The Connection.connect function is only available if Connection.auto_connect is set to True .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This page provides a basic setup guide.","title":"Getting Started"},{"location":"getting-started/#installation","text":"pip install quick-sqlite Tip If recieve an error stating that the 'pip command cannot be found', or if you have both Python 3 & Python 2 installed, try doing: pip3 install quick-sqlite","title":"Installation"},{"location":"getting-started/#basic-concepts","text":"Quick-SQLite revolves around the concept of executing operations via a function which then compiles the provided data into valid SQL, which is soon after executed. For example when the Connection.insert function is called, the provided data is compiled into SQL which would look something like INSERT INTO Table VALUES (Value Type...) . This module also revolves around the idea of making database monitoring much easier via events and connection issues a thing of the past. Here's a quick showcase on how events work: from quicksqlite import Connection con = Connection ( auto_connect = False ) @c.listen def on_connect ( db ): print ( f \"Connection to {db} has been established\" ) @c.listen def on_disconnect ( db ): print ( f \"Connection to {db} has been closed\" ) con . connect () # Do operations here... con . close () Warning The Connection.connect function is only available if Connection.auto_connect is set to True .","title":"Basic Concepts"},{"location":"quick-start/","text":"Quick Start This page demonstrates a few easy quick-start tips. A Minimal Setup Let's create a script to create a table named Employees and insert the data for an employee named Damien . It would look something like this: import quicksqlite client = quicksqlite . Connection () @client.listen def on_connect ( database ): print ( f \"Connected to {database}\" ) @client.listen def on_reconnect ( database , attempt ): if attempt == client . reconnects : print ( f \"Reconnected to {database} on the last remaining attempt!\" ) else : print ( f \"Reconnected to {database} on attempt {attempt}.\" ) client . connect () client . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) client . insert ( \"Employees\" , [ \"Damien\" , 32 , 80.00 ]) client . close () Note Don't name this file quicksqlite.py as this will conflict with the quicksqlite module and cause the script to become unusable until renamed. There's quite a bit going on here, so let's make sense of it: The first line imports the quicksqlite module that you should've installed earlier. The second line creates our Connection instance, this allows us to communicate with our database. The third line is our on_connect listener, this is a function triggered when the Connection.connect function is called. Next, we have a on_reconnect listener, if the connection is lost, or if the database is locked, we attempt to reconnect 3 times. If we manage to reconnect, this function is triggered. Our connection isn't actually established yet, to do so we need to call the Connection.connect function. We want to create a table named Employees , so, we call the Connection.create_table function, providing Employees as the table name, [\"Name\", \"Age\", \"Salary\"] as the column names and [\"TEXT\", \"INTEGER\", \"REAL\"] as the respective column types. Now that we have a table, we want to call the Connection.insert function, providing Employees as the table we want to insert into and [\"Damien\", 32, 80.00] as the data to enter into the database. Since Connection.auto_commit defaults to True , we don't need to call Connection.commit , now all that's left to do is to close the connection by calling Connection.close .","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"This page demonstrates a few easy quick-start tips.","title":"Quick Start"},{"location":"quick-start/#a-minimal-setup","text":"Let's create a script to create a table named Employees and insert the data for an employee named Damien . It would look something like this: import quicksqlite client = quicksqlite . Connection () @client.listen def on_connect ( database ): print ( f \"Connected to {database}\" ) @client.listen def on_reconnect ( database , attempt ): if attempt == client . reconnects : print ( f \"Reconnected to {database} on the last remaining attempt!\" ) else : print ( f \"Reconnected to {database} on attempt {attempt}.\" ) client . connect () client . create_table ( \"Employees\" , [ \"Name\" , \"Age\" , \"Salary\" ], [ \"TEXT\" , \"INTEGER\" , \"REAL\" ]) client . insert ( \"Employees\" , [ \"Damien\" , 32 , 80.00 ]) client . close () Note Don't name this file quicksqlite.py as this will conflict with the quicksqlite module and cause the script to become unusable until renamed. There's quite a bit going on here, so let's make sense of it: The first line imports the quicksqlite module that you should've installed earlier. The second line creates our Connection instance, this allows us to communicate with our database. The third line is our on_connect listener, this is a function triggered when the Connection.connect function is called. Next, we have a on_reconnect listener, if the connection is lost, or if the database is locked, we attempt to reconnect 3 times. If we manage to reconnect, this function is triggered. Our connection isn't actually established yet, to do so we need to call the Connection.connect function. We want to create a table named Employees , so, we call the Connection.create_table function, providing Employees as the table name, [\"Name\", \"Age\", \"Salary\"] as the column names and [\"TEXT\", \"INTEGER\", \"REAL\"] as the respective column types. Now that we have a table, we want to call the Connection.insert function, providing Employees as the table we want to insert into and [\"Damien\", 32, 80.00] as the data to enter into the database. Since Connection.auto_commit defaults to True , we don't need to call Connection.commit , now all that's left to do is to close the connection by calling Connection.close .","title":"A Minimal Setup"}]}